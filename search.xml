<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二进制-位运算</title>
      <link href="/2022/08/07/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/08/07/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>之前对位运算了解较少，本科期间学习的二进制等内容也基本上遗忘的差不多了，今天在做这个题的时候用位运算会时间复杂度会有不错的表现，<a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a>,在本文中稍微记录一下，以便以后用到相关的内容重新搜索查看这部分。</p><h3 id="1-二进制运算"><a href="#1-二进制运算" class="headerlink" title="1 二进制运算"></a>1 二进制运算</h3><p>JavaScript内部默认将二进制、十六进制、八进制数值，自动转为十进制进行运算，JavaScript 提供了原生函数，进行十进制与其他各进制之间的相互转换。从其他进制转换成十进制，有三种方式：parseInt()，Number()，+(一元运算符)。这三种方式都只能转换整数。从十进制转换成其他进制，可以使用 Number.prototype.toString()，支持小数。</p><p>自己手算二进制转十进制的话，正整数方法为，对应位的值为1的话，2的对应位数的次幂相加的和（位数从0开始），对应位的值为0的话+0；</p><p>小数的转换方法为：例如16.125<br>十进制转换为二进制，整数位与小数位分开转换，16转为10000<br>0.125采用新的转换二进制方法，如下：将小数位不断乘2，每次取其整数部位数的0或1，直到小数位变成0<br>0.125 * 2 =0.25  ———&gt;  0<br>0.250 * 2 =0.50  ———&gt;  0<br>0.500 * 2 =1.00  ———&gt;  1<br>得出0.125二进制表示为001，因此16.125二进制表示为10000.001;</p><p><strong>计算机中，负数以其正值的补码形式表示，补码为该数的反码加一。关于负数的转换和浮点数的存储（分为单精度浮点数和双精度浮点数）详细情况可以参见这里=&gt;<a href="https://www.cnblogs.com/kw4310/p/13999902.html">负数和小数点在计算机中的二进制表示</a>，<a href="https://juejin.cn/post/6844903572979597319">js浮点数精度问题</a>以后有时间可以重新详细自己整理一篇出来</strong></p><h3 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2 位运算"></a>2 位运算</h3><p>查看MDN中的位运算操作，主要包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_AND">按位与运算符</a> (&amp;) 在两个操作数对应的二进位都为 1 时，该位的结果值才为 1，否则为 0;</p><p>按<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">位非运算符（~）</a>，反转操作数的位;</p><p>按位或运算符（｜）对应位存在1及操作后对应位就变为1；</p><p>按位异或 (^)等；更详细的介绍可以去链接里的MDN文档。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Left_shift">左移操作符</a> (&lt;&lt;) 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。</p><p>下图采用MDN总结的位运算符<br><img src="/img/2022/bit_operation.png" alt="总结的位运算符"></p><h3 id="3-剑指-Offer-15-二进制中1的个数题解"><a href="#3-剑指-Offer-15-二进制中1的个数题解" class="headerlink" title="3 剑指 Offer 15. 二进制中1的个数题解"></a>3 剑指 Offer 15. 二进制中1的个数题解</h3><p>了解了上面的位运算之后就会发现这是一个很简单的问题了，代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123; <span class="comment">// &amp;按位与当二进制的相应位对应的两个数都是1时候才返回1， &lt;&lt;把左边的值相左移动i位</span></span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机原理 </category>
          
          <category> 位运算 </category>
          
          <category> 浮点数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的九种排序算法</title>
      <link href="/2022/07/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>排序算法，本文整理了之前个人学习中的九种常用的排序算法，用作个人引导复习使用，包括的方法如下图所示：<br><img src="/img/2022/sort.png" alt="九种排序算法"></p><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h3><p><strong>原理：</strong> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对,做完后，最后的元素会是最大的数。所有的元素重复以上的步骤，直到没有任何一对数字需要比较。<br><strong>动图：</strong><br><img src="/img/2022/bubbleSort.gif" alt="冒泡排序（冒大泡）"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// 外层一共判断i次，冒泡len-1次变有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123; <span class="comment">// 内层判断j次，j是未排序的数量，随i大j慢慢变小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 相邻元素两两对比，如果前面的比后面大的话就交换</span></span><br><span class="line">                [arr[j + <span class="number">1</span>], arr[j]] = [arr[j], arr[j + <span class="number">1</span>]]; <span class="comment">// 冒泡随时交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h3><p><strong>原理：</strong> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。<br><strong>动图：</strong><br><img src="/img/2022/selectionSort.gif" alt="选择排序"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// 排序len个数据排len-1次就有序了</span></span><br><span class="line">            <span class="keyword">let</span> maxIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// 得对最后一个元素也进行选择，看是否是最大的数</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[maxIndex]) &#123;     <span class="comment">// 寻找最大的数</span></span><br><span class="line">                    maxIndex = j;                 <span class="comment">// 将最大数的索引保存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            [arr[i], arr[maxIndex]] = [arr[maxIndex], arr[i]]; <span class="comment">// 等到找到一轮最大的后交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-直接插入排序（Insertion-Sort）"><a href="#3-直接插入排序（Insertion-Sort）" class="headerlink" title="3. 直接插入排序（Insertion Sort）"></a>3. 直接插入排序（Insertion Sort）</h3><p><strong>原理：</strong> 插入排序是一种最简单直观的排序算法，将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。<br><strong>动图：</strong><br><img src="/img/2022/insertionSort.gif" alt="插入排序"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 假设第一个元素为有序序列</span></span><br><span class="line">        <span class="keyword">let</span> preIndex = i - <span class="number">1</span>, currentNum = arr[i]; <span class="comment">// 设有序最后一个位置；当前的数值</span></span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &lt; currentNum) &#123; <span class="comment">// 比较所有有序和当前的数值</span></span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex]; <span class="comment">// 符合条件有序位置的变换</span></span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = currentNum; <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h3><p><strong>原理：</strong> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。<br><strong>步骤：</strong><br>直接插入排序的逆序的话首末端排序效率很低，希尔排序跳跃式分组，通过增量将元素分组，这样的话移动次数大大降低，然后缩小增量，直到增量为1；基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br><img src="/img/2022/shellsort.png" alt="希尔排序"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">//对各个增量组成的序列进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; arr.length; i++) &#123; <span class="comment">// 和直插中一样，i假设之前的为有序部分，从i的无序部分开始；</span></span><br><span class="line">            <span class="keyword">let</span> j = i - gap; <span class="comment">//gap代表直插中无序的第一个，j代表有序的最后一个,类似直插的preIndex</span></span><br><span class="line">            <span class="keyword">let</span> currentNum = arr[j + gap]; <span class="comment">// j+gap为直接插入排序中后面无序的第一个元素位置，currentNum是直插的当前数值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; currentNum) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = currentNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-快速排序（Quick-Sort）"><a href="#5-快速排序（Quick-Sort）" class="headerlink" title="5. 快速排序（Quick Sort）"></a>5. 快速排序（Quick Sort）</h3><p><strong>原理：</strong> 快速排序使用分治法，快排在平均状况下时间复杂度为Ο(nlogn)，极限情况下是n的平方，但是这种状况极少而且快排明显比其他Ο(nlogn)的算法更快；<br><strong>步骤：</strong><br>1 从数列中挑出一个元素，称为 “基准”（pivot）;<br>2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br><img src="/img/2022/quickSort.png" alt="快速排序"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码的实现方式是，选择一个中间的数字为基准点，用两个数组分别去保存比基准数小的值，</span></span><br><span class="line"><span class="comment">// 和比基准数大的值，最后递归左边的数组和右边的数组，用concat去做一个数组的合并。</span></span><br><span class="line"><span class="keyword">let</span> quickSort = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(<span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>), <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">// pivot值</span></span><br><span class="line">    <span class="comment">// let pivot = array[0]; //取第一个位置的数值为pivot基准值，但这种情况极限下的话效率低</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = []; <span class="comment">// 存小于pivot元素的数组</span></span><br><span class="line">    <span class="keyword">let</span> right = []; <span class="comment">//存大于的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 把剩下的arr的所有遍历后分到左右数组中去</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(pivot, quickSort(right)); <span class="comment">// 分别递归，并用concat连接</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优缺点：</strong><br>缺点：获取基准点使用了一个splice操作，在js中splice会对数组进行一次拷贝的操作，而它最坏的情况下复杂度为O(n)，而O(n)代表着针对数组规模的大小进行了一次循环操作。我们每次执行都会使用到两个数组空间，增大空间复杂度；concat操作会对数组进行一次拷贝，而它的复杂度也会是O(n)，对大量数据的排序来说相对会比较慢<br>优点：代码简单明了，可读性强，易于理解</p><h3 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6. 归并排序（Merge Sort）"></a>6. 归并排序（Merge Sort）</h3><p><strong>原理：</strong> 归并排序：将两个或者两个以上的有序表组合成一个新的有序表；待排表有n个元素，视为n个有序的子表，每个子表长度为1，两个归并后，得到n/2取上界个的长度为2或者1的有序表，然后继续合并，重复到一个长度为n的有序表终止。选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间<br><strong>步骤：</strong><br>如代码所示<br><img src="/img/2022/mergeSort.gif" alt="归并排序"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// </span></span><br><span class="line">        <span class="comment">//采用自上而下的归并递归方法，将完整待排序数据分为直到一个最小的1个元素，然后调用merge归并</span></span><br><span class="line">        <span class="keyword">let</span> len = data.length; <span class="comment">//len是待排序数据个数</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123; <span class="comment">// 一个就直接有序了</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取中点middle，然后分为两个子数组</span></span><br><span class="line">        <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">            left = data.slice(<span class="number">0</span>, middle),</span><br><span class="line">            right = data.slice(middle); <span class="comment">// 拆分为两个子数组</span></span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">            <span class="comment">// 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.小的加到已排序数组里</span></span><br><span class="line">            <span class="comment">// 比较大小，然后加入到result中</span></span><br><span class="line">            <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">                result.push(left.shift());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(right.shift());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// left right某一个数组为空后，把另一个中数据加到结果里</span></span><br><span class="line">        <span class="keyword">while</span> (left.length) result.push(left.shift());</span><br><span class="line">        <span class="keyword">while</span> (right.length) result.push(right.shift());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="7-桶排序-请见菜鸟教程-桶排序"><a href="#7-桶排序-请见菜鸟教程-桶排序" class="headerlink" title="7. 桶排序 请见菜鸟教程-桶排序"></a>7. 桶排序 请见<a href="https://www.runoob.com/w3cnote/bucket-sort.html">菜鸟教程-桶排序</a></h3><h3 id="8-基数排序（Radix-Sort）"><a href="#8-基数排序（Radix-Sort）" class="headerlink" title="8. 基数排序（Radix Sort）"></a>8. 基数排序（Radix Sort）</h3><p><strong>原理：</strong> 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。<br><strong>步骤：</strong><br>如代码所示，先将待排序数据放入到根据数据生成的对应的counter数组内的桶（数组）里，然后开始对个位进行排序，然后放入arr中，个位排序结束后，重新根据十位生成counter的桶，再对十位进行排序然后再放入arr中，直到最大位数也排序完成。<br><img src="/img/2022/radixSort.gif" alt="基数排序"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigits</span>) </span>&#123; <span class="comment">//maxDigits待排序数据的最大位数</span></span><br><span class="line">    <span class="keyword">let</span> counter = []; <span class="comment">// 放置桶的数组，最大为十个位置，0-9</span></span><br><span class="line">    <span class="keyword">let</span> mod = <span class="number">10</span>, dev = <span class="number">1</span>; <span class="comment">// 都是为了取个位，十位，，，的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxDigits; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123; <span class="comment">// 个位桶排完排十位百位，依次直到maxDigits</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev); <span class="comment">// 得到当前桶的值，好放入对应的桶内</span></span><br><span class="line">            <span class="keyword">if</span> (counter[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> pos = <span class="number">0</span>; <span class="comment">// 位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = counter.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// j代表从0到counter末尾最大为10遍历里面的数据后排序</span></span><br><span class="line">            <span class="keyword">if</span> (counter[j]) &#123; <span class="comment">// 防止上面末尾从0开始有为空的地方</span></span><br><span class="line">                <span class="keyword">while</span> (counter[j][<span class="number">0</span>]) &#123; <span class="comment">// 判断当前的已经部分基数排序元素是否存在</span></span><br><span class="line">                    arr[pos++] = counter[j].shift(); <span class="comment">//存在的话按照pos的位置存到arr里</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-堆排序-请见数据结构之堆排序"><a href="#9-堆排序-请见数据结构之堆排序" class="headerlink" title="9. 堆排序 请见数据结构之堆排序"></a>9. 堆排序 请见<a href="/2022/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F">数据结构之堆排序</a></h3><p>PS：本文参考地址<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">这里</a>，<a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/sort.js">此链接</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历问题-迭代和递归</title>
      <link href="/2022/04/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/04/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>递归问题可以总结成递归三部曲，即递归函数的构建，递归终止条件的确定和单次递归函数的确立这三个方面；完成了这三方面的工作后，相关问题递归算法的实现会容易许多。下面递归来实现用二叉树的前序遍历：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144.二叉树的前序遍历</a></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="comment">// 1 递归函数的确立，主要考虑函数的参数；</span></span><br><span class="line">  <span class="keyword">const</span> preTree = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2 递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    <span class="comment">// 3 单次递归函数</span></span><br><span class="line">    preTree(root.left);</span><br><span class="line">    preTree(root.right);</span><br><span class="line">  &#125;;</span><br><span class="line">  preTree(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在二叉树的递归函数返回值处理中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？详细解释看<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">这里</a>。<br>搜索一条边的写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure><p>二叉树的遍历如果采用递归方法的话相对来说比较简单，逻辑比较清晰。下面着重介绍二叉树的迭代方法</p><h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>递归的实现就是每一次递归调用都会将函数的局部变量、参数和返回地址等压入调用的栈中，然后等递归返回的时候从栈中弹出各项参数。因此我们可以直接用栈来实现二叉树的遍历。这里总结的迭代方法，二叉树前中后序上比较通用易理解的方法。</p><p>前序 法1：先序节点的访问顺序是中左右，这个方法里是直接顺序记录的，按照中左右的顺序遍历出二叉树节点；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> stack=[],result=[]; <span class="comment">// ！！！务必注意stack为[]，不用先入栈，在判断里使用节点判断，先根节点入栈while可以只用栈长度判断</span></span><br><span class="line">  <span class="keyword">let</span> cur=root; <span class="comment">// 指针，其实前序去掉cur</span></span><br><span class="line">  <span class="keyword">while</span>(stack.length||cur)&#123; <span class="comment">// 前序条件只有stack length存在就行（前提是stack里提前入根节点），中序不能这样，还是推荐和中序一样的方式；</span></span><br><span class="line">    <span class="keyword">if</span>(cur)&#123; <span class="comment">//入栈</span></span><br><span class="line">      result.push(cur.val); <span class="comment">// 中</span></span><br><span class="line">      stack.push(cur);</span><br><span class="line">      cur=cur.left; <span class="comment">//左</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cur=stack.pop();</span><br><span class="line">      cur=cur.right; <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前序 法2：这个方法里前序前序中的左右在入栈的时候顺序应该调换一下，变成中右左，因为栈先入先出，记录的结果就为左右</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preOrderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [], result = [];</span><br><span class="line">  <span class="keyword">if</span> (root) &#123; <span class="comment">// 注意判断二叉树是否为空</span></span><br><span class="line">    stack.push(root)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop(); <span class="comment">//取出当前的节点</span></span><br><span class="line">    result.push(node.val); <span class="comment">// 中 记录</span></span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123; <span class="comment">//右边 注意入栈的话先右后左，因为前序访问时中左右，栈先入先出，入栈就又左了</span></span><br><span class="line">      stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123; <span class="comment">//左边存在的话，入栈</span></span><br><span class="line">      stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序： 上述两个前序的方法，第一种稍加更改可以很方便的用来实现中序遍历，法1无需考虑进出栈顺序，中序读取顺序是左中右</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inOrderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [],</span><br><span class="line">    results = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length || root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left; <span class="comment">//左</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root = stack.pop();</span><br><span class="line">      results.push(root.val); <span class="comment">//中</span></span><br><span class="line">      root = root.right; <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序：后序遍历和前序的法2类似，后序遍历是左右中，前序的法2中出栈结果是中左右，为前序遍历结果，将法2的左右顺序调换，出栈结果为中右左，然后将结果数组逆序，得到后序遍历结果，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [], results = [];</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    stack.push(root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop();</span><br><span class="line">    results.push(node.val); <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123; <span class="comment">// 左</span></span><br><span class="line">      stack.push(node.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123; <span class="comment">// 右</span></span><br><span class="line">      stack.push(node.right)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results.reverse(); <span class="comment">//将出栈后得到的中右左逆序，为后序遍历结果，左右中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结：前序两种方法要深入理解，两种方法分别对应着中序和后序的迭代遍历实现，这是我目前了解到的比较简单的方法。</strong></p><h2 id="3-层序遍历"><a href="#3-层序遍历" class="headerlink" title="3. 层序遍历"></a>3. 层序遍历</h2><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102.二叉树的层序遍历</a></li></ul><p>二叉树的层序遍历主要是借助队列来实现，队列中每次保存的都是当前一层的信息，原理就不过多的赘述了，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; <span class="comment">// 防止空树</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> queue = [root], results = []; <span class="comment">// 根节点入队列</span></span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123; <span class="comment">// 队列不为空时</span></span><br><span class="line">        <span class="keyword">let</span> level = [], size = queue.length; <span class="comment">// 当前一层、queue length 表示当前一层长度</span></span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 当前一层存在节点的时候</span></span><br><span class="line">            <span class="keyword">const</span> node = queue.shift(); <span class="comment">// 取出节点</span></span><br><span class="line">            level.push(node.val); <span class="comment">// 值存到遍历数组里</span></span><br><span class="line">            <span class="keyword">if</span> (node.left) &#123; <span class="comment">// 左存在</span></span><br><span class="line">                queue.push(node.left); <span class="comment">//当作下一层入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right) &#123; <span class="comment">// 同理</span></span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        results.push(level); <span class="comment">// 当前一层遍历结束，存到结果数组里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>提示：求二叉树的深度等问题用层序很容易解决</strong></p><h2 id="4-判断相同的二叉树-对称"><a href="#4-判断相同的二叉树-对称" class="headerlink" title="4. 判断相同的二叉树/对称"></a>4. 判断相同的二叉树/对称</h2><ul><li><a href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101. 对称二叉树</a></li></ul><p>判断二叉树对称/相同这里是借助队列来实现，（类似层序）队列中每次保存的都是当前一层的信息，判断相同的话将左右孩子入队顺序调换就可以了，也有在此基础上判断是否子数的，但是我觉得有些复杂，判断子树不如两个树的前序节点值前后加标识，空子树用另外替换，然后include判断的方法，代码和解释如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">   <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> queue = []</span><br><span class="line">   queue.push(root.left)</span><br><span class="line">   queue.push(root.right)</span><br><span class="line">   <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">       <span class="keyword">let</span> leftNode = queue.shift() </span><br><span class="line">       <span class="keyword">let</span> rightNode = queue.shift() </span><br><span class="line">        <span class="comment">//判断一共几种情况，当都是null不能简单的返回true，还需要再继续判断</span></span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>&amp;&amp;rightNode===<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//false情况，左右结点均空上面已经处理了</span></span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>||rightNode===<span class="literal">null</span>||leftNode.val!==rightNode.val)&#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">       queue.push(leftNode.left) <span class="comment">//左节点左孩子入队</span></span><br><span class="line">       queue.push(rightNode.right) <span class="comment">//右节点右孩子</span></span><br><span class="line">       queue.push(leftNode.right) <span class="comment">//左节点右孩子</span></span><br><span class="line">       queue.push(rightNode.left) <span class="comment">//右节点左孩子</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//为空未返回false后 就是剩下的val都相等情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之堆排序</title>
      <link href="/2022/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据结构之堆排序"><a href="#1-数据结构之堆排序" class="headerlink" title="1.数据结构之堆排序"></a>1.数据结构之堆排序</h2><p>堆是一种数据结构，本文实现的二叉堆，而堆先决条件是一颗完全二叉树，由完全二叉树性质来说，可以使用数组array存放；数组array第一个位置不放元素，从1开始，对后面下标i来说，后面下标对应的父节点为当前下标除以2后结果向下取整，左子节点为当前对下标<em>2，右子节点为下标</em>2+1，可以方便找到任意节点对父子节点，在调整堆时候很方便；同时堆的实现方式很适合实现优先队列。<br>LeetCode中 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>这个问题就可以用堆的方式来解决，本文接下来主要是如何用javascript实现堆结构。</p><h2 id="2-基础组成"><a href="#2-基础组成" class="headerlink" title="2.基础组成"></a>2.基础组成</h2><p>使用数组存储堆的数据，下标从1开始计算，然后根据传入的优先级比较函数确认构建的堆结构是大顶堆还是小顶堆，默认是小顶堆，比较结果是true和false；堆结构是一颗完全二叉树，所以可以方便的找到当前节点的父节点和左右子树节点，第一节中已经介绍过了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数，能够接受自定义的优先级比较方法</span></span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">compare</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.array = [<span class="number">0</span>]; <span class="comment">// 初始化存堆数据堆数组，下标从1开始</span></span><br><span class="line">   <span class="built_in">this</span>.compare = (<span class="keyword">typeof</span> compare === <span class="string">&#x27;function&#x27;</span>) ? compare : <span class="built_in">this</span>._defaultCompare; <span class="comment">//接受传入优先级比较函数，没有传用默认的</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认比较函数，a是否比b更解决堆顶，默认小顶堆</span></span><br><span class="line"> <span class="function"><span class="title">_defaultCompare</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a &lt; b; <span class="comment">// 大顶堆为a&gt;b</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取左右还有父节点</span></span><br><span class="line"> <span class="function"><span class="title">_left</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">_right</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">_parent</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Math</span>.floor(i / <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3-新元素入堆后调整"><a href="#3-新元素入堆后调整" class="headerlink" title="3.新元素入堆后调整"></a>3.新元素入堆后调整</h2><p>将新的元素添加到整个堆的末尾，同时让新加入的元素进行“上浮”，直到符合堆定义的位置；具体操作是不断将该元素和父节点比较优先级，如果新的优先级更高，应该更接近堆顶，就和父元素交换位置，直到满足条件；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;array&#125; = <span class="built_in">this</span>;</span><br><span class="line">  array.push(item);</span><br><span class="line">  <span class="built_in">this</span>._up(array.length - <span class="number">1</span>); <span class="comment">//上浮元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上浮第i个元素，param i</span></span><br><span class="line"><span class="function"><span class="title">_up</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;array, compare, _parent&#125; = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">//i=1到堆顶，否则有机会继续上浮</span></span><br><span class="line">  <span class="comment">//_parent(i)获取父节点下标，满足上浮条件的话（不在堆顶而且比较函数返回的是true</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; compare(array[i], array[_parent(i)])) &#123; </span><br><span class="line">    <span class="built_in">this</span>._swap(_parent(i), i); <span class="comment">// 交换父节点和当前节点</span></span><br><span class="line">    i = _parent(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元素出堆后调整"><a href="#4-元素出堆后调整" class="headerlink" title="4.元素出堆后调整"></a>4.元素出堆后调整</h2><p>出堆的顺序-先和末尾元素调换位置（为了堆顶出堆后调整）然后末尾元素也就是堆顶出堆；接下来对现在的堆顶（之前的末尾元素）进行下沉调整堆结构，使之满足堆的要求；<br>下沉的话，如果当前元素的左子树存在就有下沉的可能性，然后如果当前的右子树也存在就比较左右子树，然后如果比较函数返回true，小顶堆的话也就是右子树小于左子树的话，让右子树赋值给左子树值（也就是小顶堆左子树存左右子树中最小值），然后比较左子树和当前节点的值，如果当前节点值小于左子树直接返回结束，否则的话就继续下沉节点（交换当前节点和左子树的值，然后让当前节点为左子树，继续下沉比较）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回元素，出队</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.size === <span class="number">0</span>) &#123; <span class="comment">// 当前无元素就返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123;array&#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>._swap(<span class="number">1</span>, array.length - <span class="number">1</span>); <span class="comment">//换末尾上来，堆顶放到最后</span></span><br><span class="line">    <span class="keyword">let</span> res = array.pop();</span><br><span class="line">    <span class="built_in">this</span>._down(<span class="number">1</span>);<span class="comment">//换上来的元素尝试下沉；</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下沉第i个元素 params i</span></span><br><span class="line">  <span class="function"><span class="title">_down</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;array, compare, _left, _right, size&#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//如果i是堆底，就沉不下去了</span></span><br><span class="line">    <span class="keyword">while</span> (_left(i) &lt;= size) &#123; <span class="comment">//size队列长度</span></span><br><span class="line">      <span class="keyword">let</span> left_i = _left(i);</span><br><span class="line">      <span class="comment">//选孩子节点中更靠近堆顶的，这样能保持原本的左右顺序</span></span><br><span class="line">      <span class="keyword">if</span> (_right(i) &lt;= size &amp;&amp; compare(array[_right(i)], array[left_i])) &#123; </span><br><span class="line">        left_i = _right(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果当前i比子节点更靠近堆顶，就不用下沉了</span></span><br><span class="line">      <span class="keyword">if</span> (compare(array[i], array[left_i])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//继续下沉</span></span><br><span class="line">      <span class="built_in">this</span>._swap(i, left_i);</span><br><span class="line">      i = left_i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5.完整代码"></a>5.完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数，能够接受自定义的优先级比较方法</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compare</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array = [<span class="number">0</span>]; <span class="comment">// 初始化存堆数据堆数组，下标从1开始</span></span><br><span class="line">    <span class="built_in">this</span>.compare = (<span class="keyword">typeof</span> compare === <span class="string">&#x27;function&#x27;</span>) ? compare : <span class="built_in">this</span>._defaultCompare; <span class="comment">//接受传入优先级比较函数，没有传用默认的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队 新的元素添加到整个堆的末尾，让新加入的元素进行“上浮”，到符合堆定义的位置；具体操作是不断将该元素和父节点比较优先级，</span></span><br><span class="line">  <span class="comment">//如果新的优先级更高，应该更接近堆顶，就和父元素交换位置，直到满足条件；</span></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;array&#125; = <span class="built_in">this</span>;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">this</span>._up(array.length - <span class="number">1</span>); <span class="comment">//上浮元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//上浮第i个元素，param i</span></span><br><span class="line">  <span class="function"><span class="title">_up</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;array, compare, _parent&#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//i=1到堆顶，否则有机会继续上浮</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; compare(array[i], array[_parent(i)])) &#123; <span class="comment">//_parent(i)获取父节点下标</span></span><br><span class="line">      <span class="built_in">this</span>._swap(_parent(i), i);</span><br><span class="line">      i = _parent(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回元素，出队</span></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.size === <span class="number">0</span>) &#123; <span class="comment">// 当前无元素就返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123;array&#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>._swap(<span class="number">1</span>, array.length - <span class="number">1</span>); <span class="comment">//换末尾上来，堆顶放到最后</span></span><br><span class="line">    <span class="keyword">let</span> res = array.pop();</span><br><span class="line">    <span class="built_in">this</span>._down(<span class="number">1</span>);<span class="comment">//换上来的元素尝试下沉；</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下沉第i个元素 params i</span></span><br><span class="line">  <span class="function"><span class="title">_down</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;array, compare, _left, _right, size&#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//如果i是堆底，就沉不下去了</span></span><br><span class="line">    <span class="keyword">while</span> (_left(i) &lt;= size) &#123;</span><br><span class="line">      <span class="keyword">let</span> left_i = _left(i);</span><br><span class="line">       <span class="comment">//选孩子节点中更靠近堆顶的，这样能保持原本的左右顺序</span></span><br><span class="line">      <span class="keyword">if</span> (_right(i) &lt;= size &amp;&amp; compare(array[_right(i)], array[left_i])) &#123;</span><br><span class="line">        left_i = _right(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果当前i比子节点更靠近堆顶，就不用下沉了</span></span><br><span class="line">      <span class="keyword">if</span> (compare(array[i], array[left_i])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//继续下沉</span></span><br><span class="line">      <span class="built_in">this</span>._swap(i, left_i);</span><br><span class="line">      i = left_i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回优先级最高元素，不出队</span></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列长度</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取左右还有父节点</span></span><br><span class="line">  <span class="function"><span class="title">_left</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_right</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_parent</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(i / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//交换</span></span><br><span class="line">  <span class="function"><span class="title">_swap</span>(<span class="params">i, j</span>)</span> &#123;</span><br><span class="line">    [<span class="built_in">this</span>.array[i], <span class="built_in">this</span>.array[j]] = [<span class="built_in">this</span>.array[j], <span class="built_in">this</span>.array[i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认比较函数，a是否比b更解决堆顶，默认小顶堆</span></span><br><span class="line">  <span class="function"><span class="title">_defaultCompare</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b; <span class="comment">// 大顶堆为a&gt;b</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据data数据生成堆</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">heapify</span>(<span class="params">data, compare = <span class="literal">undefined</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> heap = <span class="keyword">new</span> Heap(compare);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> data) &#123;</span><br><span class="line">      heap.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> heap = Heap.heapify([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">heap.push(<span class="number">8</span>)</span><br><span class="line">heap.pop();</span><br><span class="line">heap.pop();</span><br><span class="line">heap.pop();</span><br><span class="line">heap.size();</span><br><span class="line">heap.peek();</span><br></pre></td></tr></table></figure><p>PS：本文实现思路主要源自于<a href="https://blog.csdn.net/m0_38086372/article/details/108440136">这里</a>，但是本文实现相比之下略显繁琐，LeetCode的这个题解<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/">更简洁的实现了堆的构建</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 堆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中数字类型、条件判断相关问题</title>
      <link href="/2022/01/08/JavaScript%E4%B8%AD%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/01/08/JavaScript%E4%B8%AD%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中数字类型、条件判断相关问题"><a href="#JavaScript中数字类型、条件判断相关问题" class="headerlink" title="JavaScript中数字类型、条件判断相关问题"></a>JavaScript中数字类型、条件判断相关问题</h2><p>最近刷题的时候遇到很多涉及到字符和Number类型的问题，这里主要说下遇到的Number问题：</p><ul><li>1 数字类型的0在判断的时候是否，一般的时候都能注意到，但是注意判断的时候的处理，我觉得比较好的办法是判断的时候就别判断数字类型的东西，判断字符类型，这样就能避免这个问题。例如下面代码中只输出’0’,a<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123; <span class="comment">//a &#x27;0&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="keyword">if</span> (b) &#123; <span class="comment">//b undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(b, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>2 NaN和任何其它值比较都不相等，包括其它的NaN，这样可以用来判断存在值与否，如果undefined-‘0’后是NaN，这样就能判断当前是否存在例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (version1[i] - <span class="string">&#x27;0&#x27;</span> &gt; version2[i] - <span class="string">&#x27;0&#x27;</span>) &#123;  <span class="comment">//如果有一个为undefined其结果就为NaN，就不进入if中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Number </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-JavaScript设计模式与开发实践-发布订阅模式/观察者模式</title>
      <link href="/2021/12/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><p>发布-订阅模式定义了对象间一对多的依赖关系，当一个对象的状态发生改变的时候，所有依赖他的对象都将会得到通知。JS中，用事件模型替代传统的发布-订阅模式。</p><p>DOM事件就基于发布订阅模式，比如用户点击body后触发弹窗，我们需要订阅body上的click事件，当按钮被点击的时候，body节点会向订阅者发布这个消息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.body.click(); </span><br></pre></td></tr></table></figure><p>当然上述例子也可以添加删除更多的订阅者，不会影响到发布者内容；</p><h1 id="发布-订阅模式小例子"><a href="#发布-订阅模式小例子" class="headerlink" title="发布-订阅模式小例子"></a>发布-订阅模式小例子</h1><p>除了DOM事件，我们可以用自定义事件来事件js中的发布订阅模式，实现主要分为几个步骤如下：</p><ul><li>1 制订好谁是发布者；</li><li>2 给发布者一个缓存列表，用来存储回调函数通知订阅者；</li><li>3 发布消息的时候，发布者会遍历缓存列表，触发里面的回调函数通知订阅者；<br>还可以在回调函数里加入一些参数，订阅者可以接受参数，进行各自的处理。<br>下面的代码为售楼处和购房者的例子，正好应用此模式来实现。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> salesOffices = &#123;&#125;; <span class="comment">// 定义售楼处</span></span><br><span class="line"></span><br><span class="line">salesOffices.clientList = []; <span class="comment">// 缓存列表</span></span><br><span class="line"></span><br><span class="line">salesOffices.listen = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; <span class="comment">// 添加订阅者</span></span><br><span class="line">  <span class="built_in">this</span>.clientList.push(fn); <span class="comment">// 订阅的消息进缓存列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">salesOffices.trigger = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 发布消息</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.clientList) &#123;</span><br><span class="line">    fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// argument是发布消息时候的参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.listen(<span class="function"><span class="keyword">function</span> (<span class="params">price, squareMeter</span>) </span>&#123; <span class="comment">// 小明订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;price=&#x27;</span> + price);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;squareMeter=&#x27;</span> + squareMeter);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">salesOffices.listen(<span class="function"><span class="keyword">function</span> (<span class="params">price, squareMeter</span>) </span>&#123; <span class="comment">// 小红订阅消息</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;price=&#x27;</span> + price); </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;squareMeter=&#x27;</span> + squareMeter);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(<span class="number">200</span>, <span class="number">88</span>); <span class="comment">// 200w,88平</span></span><br><span class="line">salesOffices.trigger(<span class="number">300</span>, <span class="number">188</span>);</span><br></pre></td></tr></table></figure></li></ul><p>上述代码实现了一个最简单的发布-订阅模式，但是存在问题，比如每个订阅者都收到了发布者发布的每个消息，但是小明要是只订阅88平的消息，却收到了全部的，文中后续还增加了标识key，对此进行改进，让订阅者只收到自己感兴趣的消息。</p><p>后续还介绍了发布-订阅模式的通用实现和取消订阅的事件，有想要深入了解的可以去书中一探究竟。</p><h1 id="例子-网站登陆"><a href="#例子-网站登陆" class="headerlink" title="例子-网站登陆"></a>例子-网站登陆</h1><p>这个例子使用发布-订阅模式后的效果深深打动了我，按照自己之前的思路来说，项目开发的规模还是比较小，当登陆成功后，使用ajax一起调用设置头像，消息等等接口，这样登陆后加载内容就有着很强的耦合，每次新增需要在登陆后使用的功能模块，都要在登陆成功后加载的函数中调用，去更改函数。但是使用发布-订阅模式后对登陆信息感兴趣的模块可以自行订阅登陆成功的消息事件，这样登陆模块就不需要管业务方做什么了，登陆成功后发布登陆成功消息就可以了，这样新增功能模块也不用再更改登陆成功后的函数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了文中上面描述的，书中本章还介绍了全局的发布订阅对象、如何封装进行模块间通信、还有使用全局事件命名冲突的处理（创建命名空间）等内容。</p><p>JS中实现发布订阅模式和其他语言中还是有区别的，js中使用注册回调函数的方法代理传统的发布订阅模式，js中也无需选择使用推模型还是拉模型，通过函数的arguments可以很方便的表示参数列表，一般选推模型。</p><p><strong>优点：</strong>时间和对象上解藕等。</p><p><strong>缺点：</strong>创建订阅者本身消耗一定的时间和内存，但是可能订阅的事件到最后都没有发生，白白浪费了资源；如果过度使用模式也会导致难以追踪bug。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JavaScript设计模式与开发实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-JavaScript设计模式与开发实践-代理模式</title>
      <link href="/2021/12/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是为一个对象提供一个代用品或者占位符，以便控制对它的访问。关键之处是当客户不方便直接访问一个对象的时候，提供一个对象来控制对这个对象的访问，客户上访问的实际上是代理对象，代理对象对客户的请求作出部分处理后再把请求转发给真正要请求的对象。</p><p>代理分为虚拟代理和保护代理，虚拟代理会把一些开销很大的对象延迟到真正需要他的时候再去创建，JS中我们只讨论虚拟代理。代理和真正请求本体的接口要有一致性，这样对客户来说，访问代理和本体的话就是一致的，不需要考虑区别，只关心得到的返回结果和使用本体的地方都可以换成代理。</p><p>代理的意义，面向对象设计中，有一个单一职责原则，就是一个类（包括函数或者对象）来说，应该仅有一个引起它变化的原因，如果一个对象承担了多项职责，就会导致过高的耦合和低内聚。</p><h2 id="虚拟代理实现图片的预加载"><a href="#虚拟代理实现图片的预加载" class="headerlink" title="虚拟代理实现图片的预加载"></a>虚拟代理实现图片的预加载</h2><p>如果直接加载大的图片，图片位置一开始可能是一片空白常见的做法是先用一张清晰度低的loading图片占位，然后用异步的办法加载图片，加载好后再填充到原来的位置里。这个场景很适合虚拟代理，下面就来实现。</p><ul><li>1 创建一个普通的本体对象，负责向页面中创建img标签，并提供对外的setSrc接口，外接调用接口可以给img设置src属性： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myImage.setSrc(<span class="string">&#x27;你要添加的img url&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>2 引入代理对象proxyImage，通过代理对象加载占位图<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxyImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    myImage.setSrc(<span class="built_in">this</span>.src)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      myImage.setSrc(<span class="string">&#x27;你要添加的loading url&#x27;</span>)</span><br><span class="line">      img.src = src</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(<span class="string">&#x27;你要添加的img url&#x27;</span>)</span><br></pre></td></tr></table></figure>除此之外书中还介绍了虚拟代理合并HTTP请求、在惰性加载中的应用；<h2 id="缓存代理例子-计算乘积"><a href="#缓存代理例子-计算乘积" class="headerlink" title="缓存代理例子-计算乘积"></a>缓存代理例子-计算乘积</h2>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时如果参数和之前一样，可以直接返回前面的结果。下面为简单示例：</li><li>1 先创建用于求乘积的函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mult = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start 乘积计算&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">    a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">mult(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">//6</span></span><br><span class="line">mult(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//24</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>2 缓存代理函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxyMult = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> cache) &#123; <span class="comment">//如果传入的参数在cache中存在，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = mult.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">//把传入proxyMult的参数来计算乘积，结果加入缓存cache对象中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyMult(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//24</span></span><br><span class="line">proxyMult(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//24 这个第二次调用，参数一样，直接返回之前计算好的结果</span></span><br></pre></td></tr></table></figure>mult函数专注于计算乘积,代理对象实现缓存功能。</li></ul><p>同时，缓存代理可以用于ajax异步请求数据：项目中遇到分页的请求，同一页数据理论上只需要去后端请求一次，缓存渠道的数据，下次再请求同样的数据时候，可使用缓存数据。这里就可以引入缓存代理解决，但是实现的时候需要注意请求数据是异步操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>书中本章主要介绍了虚拟代理实现图片预加载、虚拟代理合并HTTP请求、在惰性加载中的应用以及缓存代理计算乘积、高级函数动态创建代理的例子（通过传入高级函数为各种计算创建缓存代理，将计算方法当作参数传入专门创建缓存代理的工厂里，这样可以为加减乘除创建代理，具体实现见书中本章）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JavaScript设计模式与开发实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遇到的ES6解构赋值问题</title>
      <link href="/2021/12/19/%E9%81%87%E5%88%B0%E7%9A%84ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/19/%E9%81%87%E5%88%B0%E7%9A%84ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6对象解构赋值问题"><a href="#ES6对象解构赋值问题" class="headerlink" title="ES6对象解构赋值问题"></a>ES6对象解构赋值问题</h1><p>昨天在LeetCode中刷题的时候遇到了情景，让链表A为最长链表，如果A短需要把A、B两个链表头指针和长度交换，保证A是最长的。其中用到了ES6的对象解构赋值，但是出现了一个不能理解的问题，之前也看过好多，网上也好多人在争论，js行尾加不加分号，我之前一直是加的，或者在IDE上用的时候也会设置相应的规则，但是最近在LeetCode上刷题的时候开始偷懒不加了，这样就导致了本文的问题-第一个对象解构赋值句尾不加分号，两个相邻的对象解构赋值失败。<br>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> la = <span class="string">&#x27;headA&#x27;</span>, lb = <span class="string">&#x27;headB&#x27;</span>, numa = <span class="number">1</span>, numb = <span class="number">3</span> <span class="comment">//la，lb指针，numa是headA长度</span></span><br><span class="line"><span class="keyword">if</span> (numa &lt; numb) &#123; <span class="comment">//默认设la为长的</span></span><br><span class="line">  [la, lb] = [lb, la] <span class="comment">////**********这个分号一定要写</span></span><br><span class="line">  [numa, numb] = [numb, numa]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;la&#x27;</span>,la,<span class="string">&#x27;lb&#x27;</span>,lb,<span class="string">&#x27;numa&#x27;</span>,numa,<span class="string">&#x27;numb&#x27;</span>,numb)</span><br></pre></td></tr></table></figure><p>上面的代码其中解构赋值部分</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[la, lb] = [lb, la]</span><br><span class="line">[numa, numb] = [numb, numa]</span><br></pre></td></tr></table></figure><p>相当于[la, lb] = [numb, numa]<br>打印出结果如图1:<br><img src="/img/2021/false_destructuring.png" alt="结尾无分号失败的解构赋值"><br>如下为正确结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> la = <span class="string">&#x27;headA&#x27;</span>, lb = <span class="string">&#x27;headB&#x27;</span>, numa = <span class="number">1</span>, numb = <span class="number">3</span> <span class="comment">//la，lb指针，numa是headA长度</span></span><br><span class="line"><span class="keyword">if</span> (numa &lt; numb) &#123; <span class="comment">//默认设la为长的</span></span><br><span class="line">  [la, lb] = [lb, la];</span><br><span class="line">  [numa, numb] = [numb, numa];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;la&#x27;</span>,la,<span class="string">&#x27;lb&#x27;</span>,lb,<span class="string">&#x27;numa&#x27;</span>,numa,<span class="string">&#x27;numb&#x27;</span>,numb)</span><br></pre></td></tr></table></figure><p>打印出结果如图2:<br><img src="/img/2021/success_destructuring.png" alt="结尾有分号成功的解构赋值"><br><strong>得出的结论就是，以后一定要注意写分号！（如果后续深入了解相关实现的话再来补上为什么会出现这种情况）</strong></p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> 解构赋值 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵类问题</title>
      <link href="/2021/12/17/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/17/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-59-螺旋矩阵-II"><a href="#LeetCode-59-螺旋矩阵-II" class="headerlink" title="LeetCode 59. 螺旋矩阵 II"></a>LeetCode 59. 螺旋矩阵 II</h2><p>题目为：给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p>示例 1：<br><img src="/img/2021/spiraln.jpg" alt="示例"><br>输入：n = 3</p><p>输出：[[1,2,3],[8,9,4],[7,6,5]]</p><p>螺旋矩阵类问题，没有特别好的算法去实现，可以按照上图中的来遍历，下面是思路和实现。</p><ul><li>1 生成一个n*n的矩阵，用来返回结果</li><li>2 定义上右下左的边界，分别为0,n-1,n-1,0 （这些值对应数组中的初始位置，可见上图）</li><li>3 建一个变量cur记录当前值，cur &gt; n*n的时候终止循环</li><li>4 循环里进行上右下左的判断</li><li>提示 写的过程中判断下一个要写哪个的时候可以预想一下本次结束后哪个边的值应该加还是减，这样有助于思考例如左边界到右边界后t就应该+1，然后就是上边界到下边界了，多想想上面的循环图<br>代码如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//top为0，上边界一开始为0，right一开始就是为n-1(数组从0开始n个)，画图可以看出来，</span></span><br><span class="line"><span class="keyword">let</span> t = <span class="number">0</span>, r = n - <span class="number">1</span>, b = n-<span class="number">1</span>, l=<span class="number">0</span> </span><br><span class="line"><span class="keyword">let</span> cur = <span class="number">1</span></span><br><span class="line"><span class="comment">//1 生成一个n*n的矩阵</span></span><br><span class="line"><span class="keyword">const</span> mat = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>)) </span><br><span class="line"><span class="keyword">while</span>(cur &lt;= tar)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = l; i &lt;= r; i++)mat[t][i] = cur++ <span class="comment">//左边界到右边界</span></span><br><span class="line">  t++ <span class="comment">//上边第一行结束后到第二行，该上到下了，t++</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = t; i &lt;= b; i++)mat[i][r] = cur++ <span class="comment">//上边界到下边界</span></span><br><span class="line">  r-- <span class="comment">//r--，该右到左了</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = r; i &gt;= l; i--)mat[b][i] = cur++ <span class="comment">//右边界到左边界</span></span><br><span class="line">  b-- <span class="comment">//右到左后，b--，该下到上了</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = b; i &gt;= t; i--)mat[i][l] = cur++ <span class="comment">//下边界到上边界</span></span><br><span class="line">  l++ <span class="comment">//下到上后，l++该左到右了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>学会了本题的思想，类似的54.螺旋矩阵；剑指Offer 29.顺时针打印矩阵，都能轻而易举的AC了。</li></ul><p>PS：本文思路来自于<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-JavaScript设计模式与开发实践-策略模式</title>
      <link href="/2021/12/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> 策略模式：定义一系列的算法，并且一个个封装起来，使得他们可以相互替换（达成一个目的可以有多种不同的方法）。<br> 设计模式的目的就是将算法中不变的部分和变的部分分隔开来。</p><h1 id="1-传统面向对象的策略模式实现"><a href="#1-传统面向对象的策略模式实现" class="headerlink" title="1 传统面向对象的策略模式实现"></a>1 传统面向对象的策略模式实现</h1><p>策略模式的程序至少由两部分组成。第一部分是一组策略类，封装了具体的算法，负责具体实现。第二部分是环境类Context，Context接受客户请求，随后将请求委托给某个策略类。下面代码中的是书中的策略模式例子：计算年终奖，年终奖根据基本工资和绩效计算，绩效有S、A、B，对应4、3、2倍工资，计算员工年终奖。</p><ul><li>1 先把每种绩效的计算规则封装到策略类里 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> perfomanceS = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">perfomanceS.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> perfomanceA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">perfomanceA.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> perfomanceB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">perfomanceB.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>2 环境类Context，定义奖金类<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> Bonus = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.salary = <span class="literal">null</span>; <span class="comment">//原始工资</span></span><br><span class="line">  <span class="built_in">this</span>.strategy = <span class="literal">null</span>; <span class="comment">//绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setSalary = <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.salary = salary; <span class="comment">//设置原始工资</span></span><br><span class="line">&#125;</span><br><span class="line">Bonus.prototype.setStrategy = <span class="function"><span class="keyword">function</span> (<span class="params">strategy</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.strategy = strategy; <span class="comment">//设置员工绩效等级对应的策略对象</span></span><br><span class="line">&#125;</span><br><span class="line">Bonus.prototype.getBonus = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//取得奖金数额</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.strategy) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;未设置strategy属性&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.strategy.calculate(<span class="built_in">this</span>.salary); <span class="comment">//把计算奖金的操作委托给对应的策略对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3 调用计算年终奖<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> bonus = <span class="keyword">new</span> Bonus();</span><br><span class="line">bonus.setSalary(<span class="number">10000</span>);</span><br><span class="line">bonus.setStrategy(<span class="keyword">new</span> perfomanceA()); <span class="comment">//设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log(bonus.getBonus());</span><br></pre></td></tr></table></figure>策略模式就是定义一系列的算法（perfomanceS、A、B），把他们各自封装成策略类，算法被封装在策略类的内部方法里。在用户对环境类Context发起请求时，Context总是把请求委托给这些策略对象中的某一个进行计算。上述是基于传统面向对象语言的策略模式。</li></ul><h1 id="2-javascript的的策略模式"><a href="#2-javascript的的策略模式" class="headerlink" title="2 javascript的的策略模式"></a>2 javascript的的策略模式</h1><ul><li>1 前文中，我们模拟面向对象语言让策略对象从各个策略类中创建而来。在js中函数也是对象，可以直接把strategy定义为函数：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strategies = &#123;</span><br><span class="line">  <span class="string">&#x27;S&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;A&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;B&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>2 Context环境类也不一定要用Bonus类表示，用calculateBonus函数当作Context接受请求：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> calculateBonus = <span class="function"><span class="keyword">function</span> (<span class="params">level, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[level](salary)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>3 计算年终奖<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">&#x27;S&#x27;</span>, <span class="number">20000</span>));</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-策略模式总结"><a href="#3-策略模式总结" class="headerlink" title="3 策略模式总结"></a>3 策略模式总结</h1><p> 在计算年中奖金例子中，Context类对这些策略对象发出‘计算奖金’的请求的时候，他们会返回不同的计算结果，这就是对象多态性的体现。接下来文中还介绍了两个策略模式的例子：小球各种模式移动和表单验证。小球移动是动画类根据不同的移动策略类中的策略对象来进行移动；表单验证是验证类根据不同的效验模式的策略对象进行效验。</p><p> 策略模式优点有利用组合、委托、多态等技术避免重复的判断语句；提供了对开放-封闭原则对完美支持，将算法封装在独立的策略类中；高复用性；组合和委托让Context有执行算法的能力也是继承的一种轻便方案。缺点有会增加许多策略类和策略对象；使用的时候必须了解strange类。</p><p> 在js中策略类可以很方便的用函数替代，和OOP语言实现有较大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JavaScript设计模式与开发实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-JavaScript设计模式与开发实践-单例模式</title>
      <link href="/2021/12/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式的核心是确保只有一个单例，并且提供全局访问。标准的单例模式并不复杂，只是用一个变量来标识当前是否已为某个类创建过对象，创建过的话下一次获取该类的实例时返回之前创建的对象。js中，线程池、全局缓存、window对象都是只有一个的，适用单例模式。</p><h2 id="1-透明的单例模式"><a href="#1-透明的单例模式" class="headerlink" title="1 透明的单例模式"></a>1 透明的单例模式</h2><p>用户从这个单例模式中创建对象的时候可以像使用其他任何普通类一样。下面创建一个CreateDiv单例类，负责在页面中创建唯一的div节点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateDiv = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> instance;</span><br><span class="line"><span class="keyword">let</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createComment(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">&#x27;sven1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">&#x27;sven2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alert(a === b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这段代码里，CreateDiv只负责创建对象和初始化init方法、保证只有一个对象。但是为了封装instance使用的自执行匿名函数和闭包，并且让匿名函数返回真正的Singleton方法，难以阅读。而且要是想将单例类变为普通的产生多个实例的类就需要修改CreateDiv构造函数了，下面通过引入代理类解决这个问题。</p><h2 id="2-用代理实现单例模式"><a href="#2-用代理实现单例模式" class="headerlink" title="2 用代理实现单例模式"></a>2 用代理实现单例模式</h2><p>引入代理类解决上述问题，首先构造普通的创建div的CreateDiv类，然后引入代理类；把管理单例的逻辑放到代理类ProxySingletonCreateDiv中实现，这样两个类组合起来就是单例模式的效果。本例子也是缓存代理的应用之一。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateDiv = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.html = html;</span><br><span class="line">  <span class="built_in">this</span>.init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createComment(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ProxySingletonCreateDiv = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> CreateDiv(html)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&#x27;seven&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> ProxySingletonCreateDiv(<span class="string">&#x27;seven1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alert(a === b)        </span><br></pre></td></tr></table></figure><h2 id="3-JavaScript中的单例模式"><a href="#3-JavaScript中的单例模式" class="headerlink" title="3 JavaScript中的单例模式"></a>3 JavaScript中的单例模式</h2><p>前面的实现是按照面向对象语言来的，其实JavaScript中实现单例模式，可以用let或者const在声明全局变量就可以实现，本书中因为时间较久远，var声明的变量二次声明会被覆盖，所以不能用来实现单例模式，但是let、const没有这个问题，但是仔细想想也不对，let、const是块级作用域，那在别的函数里就可以重新实现/修改这个单例了，就会导致后续单例结果不一样。还是使用闭包封装或者命名空间的办法好一点，闭包封装私有变量代码如下，只暴露接口和外界通信。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> _name = <span class="string">&#x27;xinyu&#x27;</span>, _age = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getUserInfo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _name + _age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="4-通用的惰性单例"><a href="#4-通用的惰性单例" class="headerlink" title="4 通用的惰性单例"></a>4 通用的惰性单例</h2><p>惰性单例是单例模式的重点，实际开发中应用极多。惰性是指需要调用的时候再创建，而不是页面加载好的时候就创建了，惰性单例可以优化页面加载速度。比如一个登陆弹窗，产品功能不需要上来就登陆，惰性的话，不随着页面一起加载登陆部分节约资源，然后点击登陆按钮，单例的话多次点击登陆按钮也只会创建一个登陆弹窗，进一步优化资源，惰性单例模式就很适合实现这个功能。</p><p><strong>实现通用的惰性单例:</strong></p><ol><li> 隔离出不变的部分，管理单例的逻辑可以抽象出来。逻辑是：用一个变量来标识是否创建过对象，如果是，下次直接返回这个对象。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj；</span><br><span class="line"><span class="keyword">if</span>(!obj)&#123;</span><br><span class="line">    obj = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽离出如何管理单例的逻辑，逻辑封装在getSingle函数里面，fn被当成参数传入getSingle函数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)) </span><br><span class="line">        <span class="comment">// result存在就返回result，否则就让result等于传入的参数并返回，fn.apply(this, arguments))</span></span><br><span class="line">        <span class="comment">//为了更改this指向到createLoginLayer，否则loginLayer.style.display = &#x27;block&#x27;;报错</span></span><br><span class="line">        <span class="comment">//**重要，自己理解为在this里运行fn，参数为传入arguments数组中的每一个元素</span></span><br><span class="line">        <span class="comment">//（或者把arguments传入fn中，然后把结果加入到this中）</span></span><br><span class="line">        <span class="comment">//或者去看下这个的apply部分https://segmentfault.com/a/1190000019970715</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将用于创建登陆弹窗的方法用参数fn的方式传入getSingle，（也能传入别的创建同等的单例）之后让一个新的函数用变量result来保存fn的计算结果，result变量因为在闭包中，永远不会被销毁，以后请求result，如果之前result已经被赋值，将返回这个值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createLoginLayer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//创建登陆弹窗的方法</span></span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  div.innerHTML = <span class="string">&#x27;我是登陆窗口&#x27;</span>;</span><br><span class="line">  div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">  <span class="keyword">return</span> div;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;loginBtn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> loginLayer = createSingleLoginLayer();</span><br><span class="line">  loginLayer.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JavaScript设计模式与开发实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于JavaScript的数组转树结构的WebStorm模版</title>
      <link href="/2021/11/25/%E5%9F%BA%E4%BA%8EJavaScript%E7%9A%84%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84WebStorm%E6%A8%A1%E7%89%88/"/>
      <url>/2021/11/25/%E5%9F%BA%E4%BA%8EJavaScript%E7%9A%84%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84WebStorm%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>最近在刷树相关的LeetCode题目，想在本地调试的话比较麻烦，因此写了同LeetCode里基于数组转树结构的WebStorm代码模版，具体思路就是创建一个树结点队列，数组也当做队列来用，首先把head头节点创建出并加入到树结点队列中，然后需要判断当前构建树的数组是否还有值，存在的话取队列中的第一个结点，当作父节点，接下来取数组中的第一个元素，当前的数组中取出的元素不能为null空，新建结点；否则不新建结点，最后当array数组为空的时候返回head。<br>如何创建WebStorm代码模版，请见我的另一篇文章<a href="/2021/09/19/%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95%E5%B0%BE%E6%8F%92%E6%B3%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%93%BE%E8%A1%A8/">使用头插法尾插法合并两个顺序链表</a><br>使用本文方法对数组[1, 2, 3, null, 4, 5, 6, 7]，转为二叉树结构后，如下图所示：<br><img src="/img/2021/arrayToTree.png" alt="基于JavaScript的数组转树结构的WebStorm模版"><br>数组转二叉树的代码如下，也相当于是给你一个数组，如何转为二叉树的算法题解。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 树节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line"><span class="built_in">this</span>.left = (left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line"><span class="built_in">this</span>.right = (right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数组转为树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> getTreeFromArray = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!array || !array.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line"><span class="keyword">const</span> head = <span class="keyword">new</span> TreeNode(array.shift());</span><br><span class="line">queue.push(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (array.length) &#123; <span class="comment">//当构建树的数组存在的时候</span></span><br><span class="line">    <span class="keyword">const</span> parent = queue.shift(); <span class="comment">//取相当于队列中的第一个结点，当作父节点</span></span><br><span class="line">    <span class="comment">//取数组中的第一个元素</span></span><br><span class="line">    <span class="keyword">let</span> curVal = array.shift()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> curVal === <span class="string">&#x27;number&#x27;</span>) &#123; <span class="comment">//当前的数组中取出的对应结点不能为null空，新建结点；否则不新建结点</span></span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(curVal);</span><br><span class="line">    parent.left = node;</span><br><span class="line">    queue.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取数组中的第一个元素</span></span><br><span class="line">    curVal = array.shift()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> curVal === <span class="string">&#x27;number&#x27;</span>) &#123; <span class="comment">//当前的数组中取出的对应结点不能为null空</span></span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(curVal);</span><br><span class="line">    parent.right = node;</span><br><span class="line">    queue.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head; <span class="comment">//返回树的头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTreeFromArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> WebStorm代码模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-JavaScript DOM编程艺术</title>
      <link href="/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
      <url>/2021/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-JavaScript%20DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><p>如下 html 代码，用 DOM 树的方式来看结构如书中图 7-2，就能明白各种 DOM 操作方法了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testdiv&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is <span class="tag">&lt;<span class="name">em</span>&gt;</span>my<span class="tag">&lt;/<span class="name">em</span>&gt;</span> content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/2021/html-DOM_Tree.jpg" alt="html-DOM树"></p><h3 id="页面加载完毕添加执行函数"><a href="#页面加载完毕添加执行函数" class="headerlink" title="页面加载完毕添加执行函数"></a>页面加载完毕添加执行函数</h3><p>把在页面加载完毕时候执行函数创建为一个队列，当这个处理函数上没有绑定函数时候，把新函数<br>添加给他，绑定了的话就添加到现有的末尾。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLoadEvent</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldonload = <span class="built_in">window</span>.onload;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.onload = func;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      oldonload();</span><br><span class="line">      func();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把一个节点插入到另一个之后的函数"><a href="#把一个节点插入到另一个之后的函数" class="headerlink" title="把一个节点插入到另一个之后的函数"></a>把一个节点插入到另一个之后的函数</h3><p>两个参数一个是待插入元素，一个是目标元素；将目标元素的 parentNode 属性保存到 parent 里；然后检查目标元素是否为 parent 的最后一个子元素，是的话将新元素追加到<br>parent 元素上，不是的话把新元素插入到目标元素和目标元素的下一个兄弟元素中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAfter</span>(<span class="params">newElement, targetElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = targetElement.parentNode;</span><br><span class="line">  <span class="keyword">if</span> (parent.lalastChild === targetElement) &#123;</span><br><span class="line">    parent.appendChild(newElement);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.insertBefore(newElement, targetElement.nextSibling);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js-dom-动画"><a href="#js-dom-动画" class="headerlink" title="js dom 动画"></a>js dom 动画</h3><p>书中的使用 setTimeout 函数改变位置形成动画太古老了，W3C 提供了window.requestAnimationFrame API，告诉浏览器下次重绘前执行动画。使用 dom 动画的话参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">MDN,window.requestAnimationFrame</a>，<a href="https://zh.javascript.info/js-animation">JavaScript 动画</a>，<a href="https://fed.taobao.org/blog/taofed/do71ct/js-animation-base/">淘系前端的动画文章</a></p><p>PS:完整的代码可以在我GitHub上找到：<a href="https://github.com/caichunyu/data-structure-js/blob/master/data_structure/graph.js">完整插入DOM代码示例</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> JavaScript DOM编程艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用头插法尾插法合并两个有序单链表</title>
      <link href="/2021/09/19/%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95%E5%B0%BE%E6%8F%92%E6%B3%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/09/19/%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95%E5%B0%BE%E6%8F%92%E6%B3%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>刚开始刷LeetCode上链表相关的题目，在此记录下，本文主要包括：添加js链表代码模版-webstorm代码模版（这样刷题就不用每次都重新写了），头插法、尾插法、递归合并两个有序链表。</p><h1 id="一、添加js链表代码模版"><a href="#一、添加js链表代码模版" class="headerlink" title="一、添加js链表代码模版"></a>一、添加js链表代码模版</h1><p>将下面的代码复制，然后打开webstorm设置，然后如下图中1 2 3 4，按顺序点击2中加号后，点击Live Templates，然后3中是自定的模版名字，复制代码模版到4中，然后点击应用后在webstorm里打出自定的模版名字就可以使用。<br><img src="/img/2021/webstorm_linkCode.png" alt="添加js链表代码模版到webstorm中"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">next</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val, next = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数组转为链表</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;array&#125;</span> <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> getListFromArray = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode()</span><br><span class="line"><span class="keyword">let</span> pre = dummy;</span><br><span class="line">array.forEach(<span class="function"><span class="params">x</span> =&gt;</span> pre = pre.next = <span class="keyword">new</span> ListNode(x));</span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 打印链表</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">list</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> logList = <span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;list: &#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (list) &#123;</span><br><span class="line">    str += list.val + <span class="string">&#x27;-&gt;&#x27;</span>;</span><br><span class="line">    list = list.next;</span><br><span class="line">&#125;</span><br><span class="line">str += <span class="string">&#x27;null&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、头插法"><a href="#二、头插法" class="headerlink" title="二、头插法"></a>二、头插法</h1><p>使用头插法建立单链表，头插法是将一个新结点插入到链表的头节点之后，链表中元素顺序和读入数据的顺序相反，也可以用于链表逆序。<br>合并两个有序链表，本问题的实现中分为以下几种情况，l1和l2均为空，l1 l2至少一个不为空（分三种，全不为空，l1空，l2空）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">l2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">l1 = getListFromArray(l1)</span><br><span class="line">l2 = getListFromArray(l2)</span><br><span class="line">logList(mergeTwoLists(l1,l2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwoLists</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123; <span class="comment">//均为空的情况</span></span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> head = <span class="keyword">new</span> ListNode(<span class="literal">null</span>); <span class="comment">// 头指针</span></span><br><span class="line"><span class="keyword">while</span> (l1 || l2) &#123; <span class="comment">//有一个不为空</span></span><br><span class="line">    <span class="keyword">let</span> s; <span class="comment">// 临时指针</span></span><br><span class="line">    <span class="comment">//均不为空</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2 &amp;&amp; l1.val &lt;= l2.val) &#123; </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="keyword">let</span> tail = <span class="keyword">new</span> ListNode(<span class="literal">null</span>); <span class="comment">// 临时的新节点</span></span><br><span class="line">    tail.val = l1.val;</span><br><span class="line">    tail.next = head.next;</span><br><span class="line">    head.next = tail;</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2 &amp;&amp; l1.val &gt; l2.val) &#123;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">    tail.val = l2.val</span><br><span class="line">    tail.next = head.next;</span><br><span class="line">    head.next = tail;</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l1存在l2为空，对l1剩下的进行头插法到head中</span></span><br><span class="line">    <span class="keyword">if</span> (l1 &amp;&amp; !l2) &#123;</span><br><span class="line">    s = l1;</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">    s.next = head.next</span><br><span class="line">    head.next = s; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!l1 &amp;&amp; l2) &#123; <span class="comment">//l1为空l2存在</span></span><br><span class="line">    s = l2;</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">    s.next = head.next</span><br><span class="line">    head.next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、尾插法"><a href="#三、尾插法" class="headerlink" title="三、尾插法"></a>三、尾插法</h1><p>尾插法使用一个尾指针，始终指向表尾，建立的链表元素顺序和插入的数据顺序相同。主要代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwoLists</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123; <span class="comment">//均为空的情况</span></span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> head = <span class="keyword">new</span> ListNode(<span class="literal">null</span>); <span class="comment">//新头指针</span></span><br><span class="line"><span class="keyword">let</span> t = head; <span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">while</span> (l1 || l2) &#123; <span class="comment">//有一个不为空</span></span><br><span class="line">    <span class="keyword">let</span> s;<span class="comment">//辅助指针</span></span><br><span class="line">    <span class="comment">//均不为空</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2 &amp;&amp; l1.val &lt;= l2.val) &#123;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="keyword">new</span> ListNode(<span class="literal">null</span>); <span class="comment">//新节点</span></span><br><span class="line">    tail.val = l1.val; <span class="comment">//将值赋给新节点</span></span><br><span class="line">    t.next = tail <span class="comment">//尾指针指向新节点，新节点为表尾了</span></span><br><span class="line">    t = tail;  <span class="comment">//将尾指针移到表尾</span></span><br><span class="line">    l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2 &amp;&amp; l1.val &gt; l2.val) &#123;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">    tail.val = l2.val</span><br><span class="line">    t.next = tail</span><br><span class="line">    t = tail;</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l1存在l2为空</span></span><br><span class="line">    <span class="keyword">if</span> (l1 &amp;&amp; !l2) &#123;</span><br><span class="line">    s = l1;</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">    t.next = s;</span><br><span class="line">    t = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!l1 &amp;&amp; l2) &#123; <span class="comment">//l1为空l2存在</span></span><br><span class="line">    s = l2;</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">    t.next = s;</span><br><span class="line">    t = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、递归合并链表"><a href="#四、递归合并链表" class="headerlink" title="四、递归合并链表"></a>四、递归合并链表</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!l1 || !l2) &#123; <span class="comment">// 先判断为空的情况，同时也是递归的边界</span></span><br><span class="line">    <span class="keyword">return</span> l2 || l1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l1.val &lt; l2.val) &#123; <span class="comment">//递归</span></span><br><span class="line">    l1.next= mergeTwoLists(l1.next,l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    l2.next =  mergeTwoLists(l1,l2.next);</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> WebStorm代码模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现图结构问题总结</title>
      <link href="/2021/07/12/JavaScript%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2021/07/12/JavaScript%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一-邻接表"><a href="#一-邻接表" class="headerlink" title="一  邻接表"></a>一  邻接表</h1><p>数据结构与算法JavaScript描述书中的邻接表是这样定义的，在node v14中实现后发现有问题，下面是书中实现邻接表的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertices; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>.adj[i] = [];</span><br><span class="line">    <span class="built_in">this</span>.adj[i].push(<span class="string">&#x27;&#x27;</span>); <span class="comment">//去掉这行可以正常运行</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>虽然说直接去掉push加默认空字符串的代码后就可以正常运行，但是还要知其所以然，让我们一起来看看为什么加上这一行就会导致错误呢。报错信息是TypeError: this.adj[v] is not iterable，下面是完整的graph类代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图类的构建(邻接表法表示图的边（图的顶点列表构成数组，对应数组存着相连的顶点），属性，方法，深度优先，广度优先</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vertices = v; <span class="comment">//图的顶点个数</span></span><br><span class="line">    <span class="built_in">this</span>.edges = <span class="number">0</span>; <span class="comment">//图的边</span></span><br><span class="line">    <span class="comment">////构建邻接表</span></span><br><span class="line">    <span class="built_in">this</span>.adj = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertices; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.adj[i] = [];</span><br><span class="line">        <span class="built_in">this</span>.adj[i].push(<span class="string">&#x27;&#x27;</span>); <span class="comment">//这个默认值影响到dfs的递归了，查下怎么回事,原书问题还是有些的，</span></span><br><span class="line">        <span class="comment">// 解释：加入字符的数据typeof g.adj[0] Object，对象没有iterator接口，所以for of用不了，解决办法有一些</span></span><br><span class="line">        <span class="comment">//可以自己在Symbol.iterator上部署，或者使用别的数据结构set，或者 Object.keys迭代属性，</span></span><br><span class="line">        <span class="comment">// 但是本文加入是number类型就能成功遍历，上面是思路，稍后个人博客会实现验证下</span></span><br><span class="line">        <span class="comment">// this.adj[i] = []; //邻接表初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.dfs = dfs;</span><br><span class="line">    <span class="built_in">this</span>.bfs = bfs;</span><br><span class="line">    <span class="comment">//深度优先搜索的标记访问与否的数组</span></span><br><span class="line">    <span class="built_in">this</span>.marked = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertices; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.marked[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.addEdge = addEdge; <span class="comment">//添加边</span></span><br><span class="line">    <span class="built_in">this</span>.showGraph = showGraph; <span class="comment">//展示图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加边，参数是两个顶点，传入会互相添加到对应的邻接表中，然后边到数量加一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEdge</span>(<span class="params">v, w</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.adj[v].push(w);</span><br><span class="line"><span class="built_in">this</span>.adj[w].push(v);</span><br><span class="line"><span class="built_in">this</span>.edges++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展示图打印所有顶点和相邻顶点列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showGraph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertices; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i + <span class="string">&#x27;=&gt;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="built_in">this</span>.vertices; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.adj[i][j] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.adj[i][j] + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索，深搜先从一条起始顶点开始，到达最后一个顶点，然后回溯，继续下一个路径；直到最后，没有路径位置。</span></span><br><span class="line"><span class="comment">// 实现的时候访问当前没有访问过的顶点，然后标记为已访问，再递归的访问初始顶点邻接表中其它没有访问的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.marked[v] = <span class="literal">true</span>; <span class="comment">//访问过的节点标记true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.adj[v]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.adj[v], <span class="string">&#x27;visit vertex:&#x27;</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> <span class="built_in">this</span>.adj[v]) &#123; <span class="comment">//遍历邻接表中的图节点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.marked[w]) &#123; <span class="comment">//没有访问过的话，就递归访问</span></span><br><span class="line">        <span class="built_in">this</span>.dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始以为是因为this.adj[v]是Object，对象没有iterator接口，所以for of用不了，但是，我又发现去掉后的也是object，但是邻接表中没有第一个的空字符串后，都是number就可以遍历。<br>其实push一个空字符串的话不光for of用不了，foreach也不行所以可以得知应该不是没有iterator接口的问题，在如下代码发现控制台打印出 undefined -adj[v]– undefined；相当于adj[v]没有定义，这样的话肯定是无法遍历的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> <span class="built_in">this</span>.adj[v]) &#123; <span class="comment">//遍历邻接表中的图节点</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;wwww&#x27;</span>,w,<span class="string">&#x27;vv&#x27;</span>,<span class="built_in">this</span>.adj[v])</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.marked[w]) &#123; <span class="comment">//没有访问过的话，就递归访问</span></span><br><span class="line">    <span class="built_in">this</span>.dfs(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现，字符型的number可以遍历，比如把push的空字符串变成4，可以顺利运行，但是DFS和BFS结果都会变（实际上是字符型数字默认转变为number类型），然后就相当于创建的图的的结构都变了。所以算法和原结果不同，事实证明，数据类型验证是多么重要。<br>但是还有个问题，不是说for of只能遍历Iterator接口的吗，object对象要部署Iterator接口才能用，这没部署怎么就可以了。</p><p>PS:完整的源代码可以在我GitHub上找到 <a href="https://github.com/caichunyu/data-structure-js/blob/master/data_structure/graph.js">https://github.com/caichunyu/data-structure-js/blob/master/data_structure/graph.js</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邻接表问题 </tag>
            
            <tag> Iterator </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法JavaScript描述</title>
      <link href="/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95JavaScript%E6%8F%8F%E8%BF%B0/"/>
      <url>/2021/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95JavaScript%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>基本整理了书中各个章节的基础代码片段，代码基于node v14.12.0运行，原书中有许多错误，本文中的代码都是可以运行的，但是由于本人水平有限，如有错误之处，请多多指点。</p><ul><li>1 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/array.js">数组</a></li><li>2 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/list.js">列表</a></li><li>3 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/stack.js">栈</a></li><li>4 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/queue.js">队列</a></li><li>5 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/linked_list.js">链表</a></li><li>6 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/linked_list.js">字典</a></li><li>7 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/hash_table.js">散列</a></li><li>8 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/set.js">集合</a></li><li>9 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/binary_tree.js">二叉树</a></li><li>10 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/graph.js">图</a></li><li>11 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/sort.js">排序算法</a></li><li>12 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/search.js">查找算法</a></li><li>13 <a href="https://github.com/caichunyu/data-structure-js-front-end-leaning/blob/master/data_structure/dynamic_programming.js">动态规划</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 数据结构与算法JavaScript描述 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/05/17/hello-world/"/>
      <url>/2021/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>一般学习新的语言，第一行代码就是hello world，所以我博客的第一篇文章名称就是它了，本文主要讲一下在安装过程中遇到的小问题，包括hexo-theme-next在本地显示正常，部署之后无css样式；使用Gitalk评论无法正常显示；还有主页的默认图片路径问题。</p><h2 id="hexo-theme-next-css样式不显示"><a href="#hexo-theme-next-css样式不显示" class="headerlink" title="hexo-theme-next css样式不显示"></a>hexo-theme-next css样式不显示</h2><p>本地正常显示，GitHub page 部署后css样式不显示这个是GitHub库设置的路径问题，解决方法为，在hexo配置文件_config.yml内，找到 url 这个配置项，里面设置url和root跟目录的位置。比如我的站点路径是 <a href="https://xxxxxx.github.io/">https://xxxxxx.github.io/</a> 那么，将root设置为 / 红色圈中是官方的注释<br><img src="/img/2021/hexo-theme-next_css%E6%A0%B7%E5%BC%8F%E4%B8%8D%E6%98%BE%E7%A4%BA.png" alt="hexo-theme-next css样式不显示"></p><h2 id="默认图片路径"><a href="#默认图片路径" class="headerlink" title="默认图片路径"></a>默认图片路径</h2><p>主页，文章页默认图片路径设置为绝对路径，在文章中引入图片有下面三种办法：<br>    绝对引用: 在 /source 下放图片文件夹<br>    相对引用: 使用 post_asset_folder:true 建立文章同名文件夹<br>    CDN 或者图床引用<br>注意方法一的话无法在markdown中预览，因为路径不一样。</p><h2 id="Gitalk评论无法正常显示"><a href="#Gitalk评论无法正常显示" class="headerlink" title="Gitalk评论无法正常显示"></a>Gitalk评论无法正常显示</h2><p>我遇到的问题是显示，未找到相关的Issues评论，请联系***初始化创建，然后登录的话就会进入我的博客主页，然后发现是回调地址的问题，详细参见：<a href="https://github.com/gitalk/gitalk/issues/115">hexo next 主题配置 gitalk 评论后无法初始化创建 issue</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Gitalk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
